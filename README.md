# Self-Learning RabbitMQ

主要是记录用来自己一步一步学习RabbitMQ的过程。

## MQ的基本概念
  - 流量削峰
  - 应用解耦
  - 异步处理

## MQ的种类
  - ActiveMQ
  - Kafka
  - RocketMQ
  - RabbitMQ

## RabbitMQ的四大核心概念
  - 生产者：产生消息
  - 交换机：可以和多个队列绑定
  - 队列：绑定的不同队列对应着不同的消费者或消费者组
  - 消费者：消费消息

## 其他概念
  - Broker：接受和分法消息实体，里面包含交换机和队列
  - Virtual Host：多租户和安全的场景下，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace的概念。
  - Connection：publisher/consumer和Broker之间创建的TCP连接。
  - Channel：每一个连接内部会创建一个逻辑连接，每一个进程的线程跟Channel进行连接
  - Exchange：message到底Broker的第一站，一个Exchange中对应着多个Queue。

## 工作队列模式
工作队列(又称为任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装成为消息并将其发送到队列。在后台运行的工作进程将弹出任务并且最终执行作业，当有多个工作线程时，这些工作线程将一起处理这些任务。

## 消息应答
消费者完成一个任务可能需要一定的时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况？

**RabbitMq一旦向消费者传递了一条消息，便立刻将这条消息标记为删除。在这种情况下突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息都无法处理，因为它无法收到**

**为了保证消息在发送过程中不被丢失，rabbitmq引入消息应答机制**。消息应答就是：**消费者在接受到了消息并且处理消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把这个消息删除了。**

### 自动应答机制
消息发送后立刻认为已经发送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡。

因为这种模式如果消息在被接受之前，消费者那边出现连接或者channel关闭，那么消息就丢失了。

当然另一方面这种模式下消费者那边可以接受到过载的信息，没有对传递的消息数量做限制。

有可能使得消费者这边由于接受太多没来得及处理的消息，导致这些消息的挤压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅仅适用于消费者可以高效并以某种速率能够处理这些消息的情况下使用。

### 手动应答的方式
A. Channel.basicAck 用于肯定确认 RabbitMq已知道该消息并且成功的处理消息，可以将其丢失了。

B. Channel.basicNack 用于否定确认

C. Channel.basicReject 用于否定确认，与Channel.BasicNack相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了。

**手动应答的好处:**
可以批量应答并且可以减少网络拥堵。

### 消息自动重新入队
如果消费者由于某种原因失去连接，连接关闭或者TCP连接丢失，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使一个消费者偶尔死亡，也可以确保不会丢失消息。
