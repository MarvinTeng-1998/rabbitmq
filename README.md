# 1. 入门篇

## 1.1 MQ的相关概念

### 1.1.1 什么是MQ？

本质是一个消息队列，遵循FIFO的原则。队列中放的是message，是一种跨进程的通信机制，用于上下游传递消息。“逻辑解耦+物理解耦”。使用MQ之后，消息发送上下游只需要依赖MQ，不用依赖其他服务。

### 1.1.2 为什么要用MQ？

1. 流量消峰

​		如果一个应用只能承受住1W次/s的请求，那是可以把这些请求放在MQ中，从而进行排队。进而起到流量消峰的作用。

2. 应用解耦

如果耦合调用系统，则一个系统出现故障则整体都会有问题。但是我们使用MQ进行应用的解耦，出故障的系统本应该要接受的消息被MQ缓存，等待出故障的系统重新上线，从而就能解决问题。用户无法感受到某个子系统的问题，从而保证了整个系统的高可用。

3. 异步处理

​		有些服务调用时异步的，当A需要去请求B的服务的时候，传统的方式，需要B在执行完成后通过回调函数来给到A。但是有了MQ之后我们可以使用消息总线，当B处理完成后，会封装成消息发送给MQ，MQ收到后再将消息转发给A。这样既不用B提供callback函数，同时A也不需要时刻去循环确认B是否完成。A服务还能及时得到异步处理的消息。


### 1.1.3 MQ的分类

1. ActiveMQ：

   **优点：**单机吞吐量万级，时效性ms，可用性高，基于主从架构实现高可用，消息可靠性较低的概率丢失消息

   **缺点：**维护少，高吞吐量场景少。

2. Kafka

   百万级TPS，在数据采集、传输、存储的过程中比较好。

   **优点：**性能卓越，单机写入TPS约在百万条/s，吞吐量极高。分布式的Kafka是，一个数据多个副本，少量机器宕机不会丢失数据，不会导致不可用，消费者采用Pull方式获取消息，消息有序，通过控制能够保证所有消息都被消息而且仅仅被消费一次，有优秀的第三方KafKa Web管理页面Kafka Manager。

   **缺点：**Kafka单机超过64个队列/分区，Load会发生明显的飚高现象，队列越多，load越高，发送消息响应时间变长，使用短轮询的方式，实时性取决于轮询间隔时间，消费失败不支持重试，支持消息顺序但是一台代理宕机后，就会产生消息乱序。

3. RocketMQ

   **优点：**单机吞吐量十万级，可用性非常高，分布式架构，消息可以做到0丢失，分布式的，扩展性好，支持10亿级以上的消息堆积，不会因为堆积导致性能下降。

   **缺点：**支持的客户端语言不多，没有在MQ中实现JMS等接口，有些系统需要迁移需要修改大量代码。

4. RabbitMQ

   **优点：**高并发性能好、吞吐量达到万级，健壮、稳定、易用、跨平台、支持多语言。

   **缺点：**商业版需要收费，学习成本高。

### 1.1.4 MQ的选择

1. Kafka

​		适合基于Pull的模式来处理消息消费，产生大量数据的互联网业务，例如有日志采集和传输，适合产生大量数据的互联网服务的数据收集业务。

2. RocketMQ

   天生为了金融互联网而生，对于可靠性很高的场景，尤其是电商里面的订单扣款以及业务削峰，在大量交易涌入的时候，后段可能无法及时处理的情况。

3. RabbitMQ

   性能好时效性微秒级，如果数据量没那么大，可以使用RabbitMQ。

## 1.2 RabbitMQ

### 1.2.1 四大核心概念

**生产者** - 产生数据发送消息的程序是生产者

**交换机** - （交换机绑定关联队列）可以跟N个队列进行绑定

**队列** - 绑定的不同队列对应着不同的消费者。

**消费者** - 用来消费消息的

**Broker：**接受和分发消息的实体，RabbitMQ Server就是Message Broker

**Vitual Host：**多租户和安全的场景下，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace的概念。当多个不同的用户使用同一个RabbitMQ Server提供的服务时，可以划分成多个vhost，每个用户在自己的vhost创建exchange/queue

**connection：**publisher/consumer和Broker之间创建的TCP连接。

**channel：**每一个连接内部会创建一个逻辑连接，每一个进程的线程跟Channel进行连接。不同的Channel之间是相互隔离的。AMQP包含了channel id帮助客户端和message broker来识别channel。**Channel作为轻量级的Connection极大地减少了操作系统建立TCP Connection的开销。**

**Exchange：**message到底Broker的第一站，一个Exchange中对应着多个Queue。

### 1.2.2 工作队列模式(Working Queue)

工作队列(又称为任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。相反我们安排任务在之后执行。我们把任务封装成为消息并将其发送到队列。在后台运行的工作进程将弹出任务并且最终执行作业，当有多个工作线程时，这些工作线程将一起处理这些任务。

> 注意事项：一个消息只能被处理一次，不能被处理多次。多个任务线程之间是竞争关系。

**轮询分发消息**

原则：多个工作线程，一人消费一条。Thread1消费一次Thread2就要消费一次Thread3就要消费一次。

### 1.2.3 消息应答

消费者完成一个任务可能需要一定的时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况？

**RabbitMq一旦向消费者传递了一条消息，便立刻将这条消息标记为删除。在这种情况下突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费者的消息都无法处理，因为它无法收到**

**为了保证消息在发送过程中不被丢失，rabbitmq引入消息应答机制**。消息应答就是：**消费者在接受到了消息并且处理消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把这个消息删除了。**

#### 自动应答机制

消息发送后立刻认为已经发送成功，这种模式需要在 **高吞吐量和数据传输安全性方面做权衡，**因为这种模式如果消息在被接受之前，消费者那边出现连接或者channel关闭，那么消息就丢失了，当然另一方面这种模式下消费者那边可以接受到过载的信息，**没有对传递的消息数量做限制。**当然这样有可能使得消费者这边由于接受太多没来得及处理的消息，导致这些消息的挤压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，**所以这种模式仅仅适用于消费者可以高效并以某种速率能够处理这些消息的情况下使用。**

#### 手动应答的方法

​	A. Channel.basicAck 用于肯定确认 RabbitMq已知道该消息并且成功的处理消息，可以将其丢失了。

​	B. Channel.basicNack 用于否定确认

​	C. Channel.basicReject 用于否定确认，与Channel.BasicNack相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了。

#### 手动应答的好处

​	可以批量应答并且可以减少网络拥堵。

#### 消息自动重新入队

​	如果消费者由于某种原因失去连接，连接关闭或者TCP连接丢失，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使一个消费者偶尔死亡，也可以确保不会丢失消息。

